These are notes for the latest version of the Pulse Sensor Hardware and Software

Pulse Sensor created by Joel Murphy & Yury Gitman, Summer 2011
CC Attribution Share-Alike    http://creativecommons.org/licenses/by-sa/3.0/us/

PLEASE READ THIS ENTIRE README BEFORE EMBARKING ON PULSE SENSOR EXPERIMENTS

General Hardware Notes:

RED wire = +3V to +5V
BLACK wire = GND
PURPLE wire = signal (analog pin 0 in arduino code) 

Pulse Sensor comes with an ear clip and two velcro dots (hook side) along with 3 clear plastic stickers.
It is advised that you don't attach Pulse Sensor to any of these accessories right away.
Give yourself a chance to play with the sensor and see how it works on various body parts.
Pulse Sensor works best on capillary tissue. 
Upload the included arduino code (A_PulseSensor_06) to your favorite arduino board.
Plug the Pulse Sensor into Power, Ground, and Analog Pin 0.
Open and run the Processing code (P_PulseSensor_06).
NOTE, you may need to adjust the Serial Port selection. See comments in the code and http://processing.org/reference/libraries/serial/index.html for more.

Try first on by holding Pulse Sensor on your fingertip and earlobe (heart side = skin contact side)
Too much pressure on the sensor will squeeze blood out of area you are measureing!
Too little pressure on the sensor will not read pulse and allow ambient light noise!
Sweet-spot pressure to read clear signal from heartbeat.
Pulse Sensor signal may need to settle for a few seconds.
 
Try different parts of your finger/earlobe/(fill in the body part here) as you are testing and getting used to the sensor. You may find that some fingers or parts of fingers and earlobes are better than others. For example, I find that when I position the sensor so that the edge of the PCB is at the bottom edge of my earlobe I get an awesome signal. We are all different original people! Play around to find the best spot on you. If you body parts are cold, or your circulation is poor, you may not get good signal. Warm body parts have alot of blood. Cold body parts are your body's way of conserving heat in cold weather.

PULSE SENSOR HAS EXPOSED ELECTRONIC COMPONENTS AND CONNECTIONS ON IT!
DO NOT IMMERSE IN WATER! AVOID DIRECT CONTACT WITH SWEATY, OILY SKIN!

There will be forthcoming tutorial on making Pulse Sensor water resistant. 
If you think you have a good idea for 'sealing' Pulse Sensor from wetness, go for it! And let us know!


General Software Notes:

Arduino code is called 'A_PulseSensor_06'
Processing code is called 'P_PulseSensor_06'

Pulse Sensor PURPLE wire goes to Analog Pin 0
Arduino will blink pin 13 in time with your heartbeat
Arduino code designed to fade an LED on Digital Pin 11
Arduino does all the work finding heart beat and determining heart rate
Processing code is a simple data visualizer.
Program the Arduino, then run the Processing code to view Pulse Sensor data.

Pulse data window plots sensor data 1:1 (ADC result : pixel)
Processing has auto calibration for the Pulse Data window range, so your waveform will always
be visible in the data window
Keypress 'S' or 's' will take a picture of the processing sketch (.tif)

CHANGES TO ARDUINO CODE FROM LAST VERSION:
A_PulseSensor_06 uses a digital bandpass filter which greatly improves the signal processing.
This version is the prototype of a Pulse Sensor library for Arduino.
The Pulse Sensor data is sampled every milisecond, timed by an interrupt generated by Timer1.
Use of Timer1 for this purpose breaks PWM output on pins 9 and 10.
A handful of variables are updated inside the Timer1 Interrupt Service Routine.
These are they:
Pulse :	    boolean is true when beat is found and becomes false in time with pin 13 LED turning off
Signal :    int that holds the analog signal data straight from the sensor. updated every 1mS.
HRV  :      int that holds the time between the last two beats. 1mS resolution.
B  :        boolean that is made true whenever HRV is updated. User must reset.
BPM  :      int that holds the heart rate value. derived from averaging HRV every 10 pulses.
QS  :       boolean that is made true whenever BPM is updated. User must reset.
Scale  :    int that works abit like gain. use to change the amplitude of the digital filter output. useful range 12<>20 : high<>low default = 12
FSignal  :  int that holds the output of the digital filter/amplifier. updated every 1mS.

KNOWN ISSUES:
The Pulse Sensor signal is a small saw-tooth waveform that is riding on a changing DC voltage.
That changing DC voltage can make the signal hard to read, even with the digital filter.
The incoming signal must be NORMALIZED in order for it to be useful as input to the digital filter.
NORMALIZING means centering the amplitude of the waveform at value 0.
This is done in code by averaging 300 Pulse Sensor values to derive an offset. 
Here's the code from the Arduino Sketch:

// First normailize the waveform around 0
readings += Signal; 		// take a running total
sampleCounter++;     		// we do this every milisecond. This timer is used as counter and clock
if ((sampleCounter %300) == 0){ // adjust number of readings to average as needed
  offset = readings / 300;      // average the running total
  readings = 0;                 // reset running total
}
NSignal = Signal - offset;      // normalizing here

The averaging works pretty well, but it takes some amount of time, and sometimes the Pulse signal can be lost for a couple of beats. If you have a better way to normalize the pulse signal in code, let us know!
Another way to address this issue is with hardware. If you have room in your project, I advise to put the Pulse Sensor signal through a passive highpass filter made of a 2.2uF capacitor and a couple of 220K resistors, like so:

				+V
				    \
				    /  220K
				    \
				    /
Pulse Sensor PURPLE wire -----||--------- To Arduino Analog Pin 0
			    2.2uF   \
				    /
				    \  220K
				    /
				GND

This circuit will center the Pulse Sensor signal around +V/2 (512 on the ADC). 
Yes, our hardware design will be updated with these parts in future version  ;)


NOTES ON THE DIGITAL FILTER:
The following assumes a working knowlege of electronics filters in general.
It stands to reason that if one can model an electronic filter with math (either a passive filter, or an active filter) then one can produce an equation that does the same thing to a digitized analog signal. It is important to have a very regular sample rate, which I'm able to do by putting my analogRead() inside of the Timer1 interrupt service routine that gets tripped every 1mS. It's also important to have a high sample frequency compared to the frequency(ies) of interst. The filter that I made for this version of Pulse Sensor arduino code may not be the very best, but it works right nice. Here's how I worked it out.
Through the magic of mathematics, and online calculators built by folks much smarter than me, filter design is a fairly straight forward process. The basic parameters that you need to know are the filter type, the order, sample rate, and cut-off or corner frequency. 
I built a bandpass filter out of 3rd order Butterworth lowpass and highpass filters with cutoff freqencies of .8Hz and 5Hz using the calculator at this website www-users.cs.york.ac.uk/~fisher/mkfilter/trad.html. The calculator derives coefficients and formula necessary to model the filter process with math, and the coefficient results look something like this:
b1 = 0.9043475314 
b2 = -2.8039479774 
b3 =  2.8994795946
Floating point numbers are a bit of a drag. They take up memory, and take more time to process. It would be better to get rid of them. I was able to avoid using floating point variables by scaling the numbers up. This is very easy to do with binary. example:
0.9043475314 in binary is 0.11100111100000110101000111011111 
shifting the bits leftward 12 times = 111001111000.00110101000111011111 
That gives us a prety good resolution, and when converted back to decimal, we get 3704.
The process is repeated for all of the numbers that the calculator comes up with while maintaining the sign. Now the next trick is that the signal to be filtered must be bit shifted as well, or else the scales will be off and the results get very lousy. After playing around with shifting the numbers around, I came up with the equation in the arduino sketch. It works quite well, but there also may be better filter versions out there. Please share your experiments on the Pulse Sensor forum!

a servicable binary converter here http:
www.mathsisfun.com/binary-decimal-hexadecimal-converter.html
a good site for explaining the bit shift scaling here:
http://www.beis.de/Elektronik/Filter/AnaDigFilt/AnaDigFilt.html


These code examples are in BETA. Critisism is greatly apprecieated ;)
Seriously, I was not raised a coder. If you see methods for imporvement please share them.

